import numpy as np
import pandas as pd
import subprocess
import pathlib
import tempfile
import sys
import os
import uuid
import pathlib

os.environ['OCTAVE_EXECUTABLE'] = "C:\\Program Files\\GNU Octave\\Octave-6.3.0\\mingw64\\bin\\octave-cli.exe"
from oct2py import octave


def ltl_to_csv(in_path, out_path):
    PATH = "c:\\Program Files\\LeddarTech\\LeddarConfigurator\\LeddarHost.exe"
    process_args = [PATH, "-p", 'LtPlug_EngTools', '-f', 'ExportToCSV',
                    '-file', in_path, '-out', out_path, '-ff', '0', '-dm', '8']
    process = subprocess.Popen(
        process_args, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    out, err = process.communicate()
    print(process.returncode)


CWD = pathlib.Path(os.getcwd())

DATA_WORK_ROOT = f"{os.getcwd()}/.ltl_work"
if not os.path.exists(DATA_WORK_ROOT):
    os.makedirs(DATA_WORK_ROOT)

TEST_ROOT = pathlib.Path("C:\\GitLab\\LTSimulationEngine\\Tests")
TEST_INCLUDE_ROOT = TEST_ROOT / "Include"


working_fpga_tmp_root = f"{os.getcwd()}/.fpga_work"
if not os.path.exists(working_fpga_tmp_root):
    os.makedirs(working_fpga_tmp_root)
reference_model_executable_path = "C:\\GitLab\\LTSimulationEngine\\Tests\\Scripts\\create_fpga_test\\fpga_model\\dsp_model"
reference_model_config_path = "C:\\GitLab\\LTSimulationEngine\\Tests\\Scripts\\create_fpga_test\\fpga_model\\dsp_config\\root_cfg_Cyclops.json"


def ltl_to_df(ltl_file_path):
    if not ltl_file_path.endswith(".ltl"):
        return

    out_file_basename = f"{uuid.uuid4()}"
    out_file_path = f"{DATA_WORK_ROOT}/{out_file_basename}.csv"
    out_real_file_path = f"{DATA_WORK_ROOT}/{out_file_basename}_RawTraces.csv"
    ltl_to_csv(ltl_file_path, out_file_path)

    df = pd.read_csv(out_real_file_path, header=2, delimiter=";")

    os.unlink(out_real_file_path)

    df = df.rename(columns={"Frame timestamp": "ts",
                   "Scanning index": "LaserAngle", "Imaging index": "PD"})

    rows = df.shape[0]
    frames = np.repeat(np.arange(1, int(rows / 1024) + 1), 1024)
    df["frame"] = frames

    return df


tile_pd_count = 32
tile_scan_count = 32
tile_waveform_count = tile_pd_count * tile_scan_count

# tile_pd_count = 32
# tile_scan_count = 32
# tile_waveform_count = tile_pd_count * tile_scan_count


def write_header(out):
    out.write(
        "/*******************************************************************************************\n")
    out.write("* \n")
    out.write("*                                  DO NOT EDIT THIS FILE\n")
    out.write("* \n")
    out.write(
        "* This file was automatically generated, any modification to it will be lost\n")
    out.write("* \n")
    out.write(
        "*******************************************************************************************/\n")

def write_array_row(out, index, row, is_last, write_hex):
    if not write_hex:
        out.write(
            f"    /* IDX: {index}*/ {', '.join([str(i) for i in row])}{'' if is_last else ','}\n")
    else:
        out.write(
            f"    /* IDX: {index}*/ {', '.join([hex(i) for i in row])}{'' if is_last else ','}\n")


def write_tuple(tup):
    return f"{{{', '.join([str(i) for i in tup])}}}"

def write_tensor_shape(out, type, varname, shape):
    shape_str = ", ".join([str(i) for i in shape[1:]])
    out.write(f"std::vector<std::vector<uint32_t>> {varname}TensorShapeData = {{ {', '.join([f'{{ {shape_str} }}' for i in range(shape[0])])} }};\n")
    out.write(f"sTensorShape {varname}({varname}TensorShapeData, sizeof({type}));\n")

def write_waveform_array(out, type, varname, data, write_hex=False):
    out.write(f"std::vector<std::vector<uint32_t>> {varname}TensorShapeData = {{ {', '.join([f'{{ {tile_scan_count}, {tile_pd_count}, {data.shape[-1]} }}' for i in range(data.shape[0])])} }};\n")
    out.write(f"sTensorShape {varname}TensorShape({varname}TensorShapeData, sizeof({type}));\n")
    out.write(f"std::vector<{type}> {varname} = {{\n")
    for i in range(data.shape[1]):
        write_array_row(out, i, data[0, i, :], i == (data.shape[1]-1), write_hex)
    out.write(f"}};\n")

def write_tensor_data(out, type, varname, data, shape, write_hex=False):
    data_to_write = np.reshape(data, shape)
    out.write(f"std::vector<{type}> {varname} = {{\n")
    for i in range(data_to_write.shape[0]):
        write_array_row(out, i, data_to_write[i, :], i == (shape[0]-1), write_hex)
    out.write(f"}};\n")

def write_array(out, type, varname, data, write_hex=False):
    out.write(f"std::vector<{type}> {varname} = {{\n")
    for i in range(data.shape[1]):
        write_array_row(out, i, data[0, i, :], i == (data.shape[1]-1), write_hex)
    out.write(f"}};\n")

def write_tensor(out, type, var_name, linear_numpy_array, tile_count, scan_count, pd_count):
    out_array = np.reshape(linear_numpy_array, (tile_count, pd_count, scan_count, -1))
    out_array = np.transpose(out_array, [0, 2, 1, 3])
    out_array = np.reshape(out_array, (tile_count, scan_count * pd_count, -1))
    write_waveform_array(out, type, var_name, out_array)

def write_tile_tensor_data(out, type, var_name, linear_numpy_array, tile_count, scan_count, pd_count):
    out_array = np.reshape(linear_numpy_array, (tile_count, pd_count, scan_count, -1))
    out_array = np.transpose(out_array, [0, 2, 1, 3])
    write_tensor_data(out, type, var_name, out_array, (tile_count * scan_count * pd_count, -1))

def create_tensor_node(out, data_variable, node_variable_name, shape):
    out.write(f"    sDataInitializerComponent lInputDataInitializer( {data_variable} );\n")
    out.write(f"    auto {node_variable_name} = MultiTensorValue( aScope, lInputDataInitializer, {shape} );\n")

def return_(out, data_variable):
    out.write(f"    return {data_variable};\n")

def newline(out):
    out.write("\n")

function_signatures = []
def begin_function(out, signature):
    out.write(f"{signature}\n")
    out.write("{\n")
    function_signatures.append(f"{signature};")

def end_function(out):
    out.write("}\n\n")

def write_signatures(out):
    write_header(out)
    newline(out)
    out.write("\n".join(function_signatures))


def create_fpga_output_dataframe(input_df, path):
    global tile_pd_count
    global tile_scan_count
    global tile_waveform_count

    result_blinder = pd.read_csv(f"{path}/result_blinder.csv", sep=';')
    result_cfar = pd.read_csv(f"{path}/result_cfar.csv", sep=';')
    result_fir_filter = pd.read_csv(f"{path}/result_fir.csv", sep=';')
    result_sn_filter = pd.read_csv(f"{path}/result_sn_rem.csv", sep=';')
    result_stats = pd.read_csv(f"{path}/result_stats.csv", sep=';')
    result_detect_max = pd.read_csv(f"{path}/result_detect_max.csv", sep=';')
    result_tile = np.reshape(np.fromfile(f"{path}/tile.bin", dtype="I"), (-1, 80))

    traces = input_df[[col for col in input_df.columns if col.startswith("Sample")]].to_numpy()

    with open(TEST_INCLUDE_ROOT / "TestWaveformStatistics.cpp", 'w') as out:
        write_header(out)
        newline(out)
        out.write('#include "TestDataFunctions.h"\n\n\n')
        begin_function(out, "std::vector<float> GetWaveformBaselineData()")
        data = result_stats['baseline'].to_numpy()
        data = np.reshape(data, (-1, tile_scan_count, tile_pd_count))
        data = np.transpose(data, [0, 2, 1])
        write_tensor_data(out, "float", "lBaselineOutputData", data, [tile_scan_count, tile_pd_count] )
        return_(out, "lBaselineOutputData")
        end_function(out)

        begin_function(out, "OpNode GetWaveformBaselineNode(Scope &aScope)")
        out.write("    auto lNodeData = GetWaveformBaselineData();\n")
        write_tensor_shape(out, "uint32_t", "lTensorShape", [1, tile_scan_count, tile_pd_count ])
        create_tensor_node(out, "lNodeData", "lNode", "lTensorShape")
        return_(out, "lNode")
        end_function(out)

        begin_function(out, "std::vector<float> GetWaveformNoiseData()")
        data = result_stats['noise_std'].to_numpy()
        data = np.reshape(data, (-1, tile_scan_count, tile_pd_count))
        data = np.transpose(data, [0, 2, 1])
        write_tensor_data(out, "float", "lBaselineOutputData", data, [tile_scan_count, tile_pd_count])
        return_(out, "lBaselineOutputData")
        end_function(out)

        begin_function(out, "OpNode GetWaveformNoiseNode(Scope &aScope)")
        out.write("    auto lNodeData = GetWaveformNoiseData();\n")
        write_tensor_shape(out, "uint32_t", "lTensorShape", [1, tile_scan_count, tile_pd_count ])
        create_tensor_node(out, "lNodeData", "lNode", "lTensorShape")
        return_(out, "lNode")
        end_function(out)

    with open(TEST_INCLUDE_ROOT / "TestStaticNoiseRemoval.cpp", 'w') as out:
        write_header(out)
        newline(out)
        out.write('#include "TestDataFunctions.h"\n\n\n')

        data_array = result_sn_filter['data_o'].to_numpy()
        begin_function(out, "std::vector<float> GetPostStaticNoiseWaveformData()")
        write_tile_tensor_data(out, "float", "lInputData", data_array, 1, tile_scan_count, tile_pd_count)
        newline(out)
        return_(out, "lInputData")
        end_function(out)

        begin_function(out, "OpNode GetPostStaticNoiseWaveformNode(Scope &aScope)")
        out.write("    auto lNodeData = GetPostStaticNoiseWaveformData();\n")
        write_tensor_shape(out, "float", "lTensorShape", [1, tile_scan_count, tile_pd_count, int(len(data_array) / (tile_scan_count * tile_pd_count))])
        create_tensor_node(out, "lNodeData", "lNode", "lTensorShape")
        return_(out, "lNode")
        end_function(out)

    with open(TEST_INCLUDE_ROOT / "TestPacketHeader.cpp", 'w') as out:
        write_header(out)
        newline(out)
        out.write('#include "TestDataFunctions.h"\n\n\n')

        begin_function(out, "std::vector<uint32_t> GetPacketHeaderData()")
        # out_array = np.reshape(result_tile, [32, 32, -1])
        out_array = np.reshape(result_tile, [1, 1024, -1])
        out_array = out_array[:, :, 0:5]
        write_tile_tensor_data(out, "uint32_t", "lBaselineOutputData", out_array, 1, tile_scan_count, tile_pd_count)
        return_(out, "lBaselineOutputData")
        end_function(out)

    with open(TEST_INCLUDE_ROOT / "TestWaveformData.cpp", 'w') as out:
        write_header(out)
        newline(out)
        out.write('#include "TestDataFunctions.h"\n\n\n')

        data_array = traces.flatten()
        begin_function(out, "std::vector<float> GetWaveformData()")
        write_tile_tensor_data(out, "float", "lInputData", data_array, 1, tile_scan_count, tile_pd_count)
        newline(out)
        return_(out, "lInputData")
        end_function(out)

        begin_function(out, "OpNode GetWaveformNode(Scope &aScope)")
        out.write("    auto lNodeData = GetWaveformData();\n")
        write_tensor_shape(out, "float", "lTensorShape", [1, tile_scan_count, tile_pd_count, int(len(data_array) / (tile_scan_count * tile_pd_count))])
        create_tensor_node(out, "lNodeData", "lNode", "lTensorShape")
        return_(out, "lNode")
        end_function(out)

    with open(TEST_INCLUDE_ROOT / "TestFilteredWaveformData.cpp", 'w') as out:
        write_header(out)
        newline(out)
        out.write('#include "TestDataFunctions.h"\n\n\n')

        data_array = result_fir_filter['data_o'].to_numpy()
        begin_function(out, "std::vector<float> GetFilteredWaveformData()")
        write_tile_tensor_data(out, "float", "lInputData", data_array, 1, tile_scan_count, tile_pd_count)
        newline(out)
        return_(out, "lInputData")
        end_function(out)

        begin_function(out, "OpNode GetFilteredWaveformNode(Scope &aScope)")
        out.write("    auto lNodeData = GetFilteredWaveformData();\n")
        write_tensor_shape(out, "float", "lTensorShape", [1, tile_scan_count, tile_pd_count, int(len(data_array) / (tile_scan_count * tile_pd_count))])
        create_tensor_node(out, "lNodeData", "lNode", "lTensorShape")
        return_(out, "lNode")
        end_function(out)

    with open(TEST_INCLUDE_ROOT / "TestThresholdsData.cpp", 'w') as out:
        write_header(out)
        newline(out)
        out.write('#include "TestDataFunctions.h"\n\n\n')

        data_array = result_cfar['threshold'].to_numpy()
        begin_function(out, "std::vector<float> GetThresholdData()")
        write_tile_tensor_data(out, "float", "lInputData", data_array, 1, tile_scan_count, tile_pd_count)
        newline(out)
        return_(out, "lInputData")
        end_function(out)

        begin_function(out, "OpNode GetThresholdNode(Scope &aScope)")
        out.write("    auto lNodeData = GetThresholdData();\n")
        write_tensor_shape(out, "float", "lTensorShape", [1, tile_scan_count, tile_pd_count, int(len(data_array) / (tile_scan_count * tile_pd_count))])
        create_tensor_node(out, "lNodeData", "lNode", "lTensorShape")
        return_(out, "lNode")
        end_function(out)

    with open(TEST_INCLUDE_ROOT / "TestDistanceData.cpp", 'w') as out:
        write_header(out)
        newline(out)
        out.write('#include "TestDataFunctions.h"\n\n\n')

        begin_function(out, "std::vector<float> GetDistanceData()")
        result_detect_max["det_bin"] = result_detect_max["det_bin"] / 64.0
        grouped = result_detect_max.groupby(['trace'])
        data = []
        for name, group in grouped:
            data.append((name, list(group["det_index"].to_numpy()), list(group["det_bin"].to_numpy())))

        valid_detections = np.zeros([tile_waveform_count, traces.shape[1]], dtype=np.float32)
        for indices in data:
            valid_detections[indices[0], indices[1]] = indices[2]

        write_tensor(out, "float", "lInputData", valid_detections, 1, tile_scan_count, tile_pd_count)
        newline(out)
        return_(out, "lInputData")
        end_function(out)

        begin_function(out, "OpNode GetDistanceNode(Scope &aScope)")
        out.write("    auto lNodeData = GetDistanceData();\n")
        write_tensor_shape(out, "float", "lTensorShape", [1, tile_scan_count, tile_pd_count, int(len(data_array) / (tile_scan_count * tile_pd_count))])
        create_tensor_node(out, "lNodeData", "lDataNode", 'lTensorShape')
        newline(out)
        return_(out, "lDataNode")
        end_function(out)

    with open(TEST_INCLUDE_ROOT / "TestAmplitudeData.cpp", 'w') as out:
        write_header(out)
        newline(out)
        out.write('#include "TestDataFunctions.h"\n\n\n')

        begin_function(out, "std::vector<float> GetAmplitudeData()")
        grouped = result_detect_max.groupby(['trace'])
        data = []
        for name, group in grouped:
            data.append((name, list(group["det_index"].to_numpy()), list(group["det_mag"].to_numpy())))

        valid_detections = np.zeros([tile_waveform_count, traces.shape[1]], dtype=np.float32)
        for indices in data:
            valid_detections[indices[0], indices[1]] = indices[2]

        write_tensor(out, "float", "lInputData", valid_detections, 1, tile_scan_count, tile_pd_count)
        newline(out)
        return_(out, "lInputData")
        end_function(out)

        begin_function(out, "OpNode GetAmplitudeNode(Scope &aScope)")
        out.write("    auto lNodeData = GetAmplitudeData();\n")
        write_tensor_shape(out, "float", "lTensorShape", [1, tile_scan_count, tile_pd_count, int(len(data_array) / (tile_scan_count * tile_pd_count))])
        create_tensor_node(out, "lNodeData", "lDataNode", 'lTensorShape')
        newline(out)
        return_(out, "lDataNode")
        end_function(out)

    with open(TEST_INCLUDE_ROOT / "TestPulseIsSaturated.cpp", 'w') as out:
        write_header(out)
        newline(out)
        out.write('#include "TestDataFunctions.h"\n\n\n')

        data_array = result_blinder['blind_on'].to_numpy()
        begin_function(out, "std::vector<uint8_t> GetPulseIsSaturatedData()")
        write_tile_tensor_data(out, "uint8_t", "lInputData", data_array, 1, tile_scan_count, tile_pd_count)
        newline(out)
        return_(out, "lInputData")
        end_function(out)

        begin_function(out, "OpNode GetPulseIsSaturatedNode(Scope &aScope)")
        out.write("    auto lNodeData = GetPulseIsSaturatedData();\n")
        write_tensor_shape(out, "uint8_t", "lTensorShape", [1, tile_scan_count, tile_pd_count, int(len(data_array) / (tile_scan_count * tile_pd_count))])
        create_tensor_node(out, "lNodeData", "lNode", "lTensorShape")
        return_(out, "lNode")
        end_function(out)

    with open(TEST_INCLUDE_ROOT / "TestPreSaturationBaseline.cpp", 'w') as out:
        write_header(out)
        newline(out)
        out.write('#include "TestDataFunctions.h"\n\n\n')

        data_array = result_blinder['bl_before'].to_numpy()
        begin_function(out, "std::vector<float> GetPreSaturationBaselineData()")
        write_tile_tensor_data(out, "float", "lInputData", data_array, 1, tile_scan_count, tile_pd_count)
        newline(out)
        return_(out, "lInputData")
        end_function(out)

        begin_function(out, "OpNode GetPreSaturationBaselineNode(Scope &aScope)")
        out.write("    auto lNodeData = GetPreSaturationBaselineData();\n")
        write_tensor_shape(out, "float", "lTensorShape", [1, tile_scan_count, tile_pd_count, int(len(data_array) / (tile_scan_count * tile_pd_count))])
        create_tensor_node(out, "lNodeData", "lNode", "lTensorShape")
        return_(out, "lNode")
        end_function(out)

    with open(TEST_INCLUDE_ROOT / "TestPostSaturationBaseline.cpp", 'w') as out:
        write_header(out)
        newline(out)
        out.write('#include "TestDataFunctions.h"\n\n\n')

        data_array = result_blinder['bl_after'].to_numpy()
        begin_function(out, "std::vector<float> GetPostSaturationBaselineData()")
        write_tile_tensor_data(out, "float", "lInputData", data_array, 1, tile_scan_count, tile_pd_count)
        newline(out)
        return_(out, "lInputData")
        end_function(out)

        begin_function(out, "OpNode GetPostSaturationBaselineNode(Scope &aScope)")
        out.write("    auto lNodeData = GetPostSaturationBaselineData();\n")
        write_tensor_shape(out, "float", "lTensorShape", [1, tile_scan_count, tile_pd_count, int(len(data_array) / (tile_scan_count * tile_pd_count))])
        create_tensor_node(out, "lNodeData", "lNode", "lTensorShape")
        return_(out, "lNode")
        end_function(out)

    with open(TEST_INCLUDE_ROOT / "TestSaturatedPulseLength.cpp", 'w') as out:
        write_header(out)
        newline(out)
        out.write('#include "TestDataFunctions.h"\n\n\n')

        data_array = result_blinder['pulse_len'].to_numpy()
        begin_function(out, "std::vector<uint32_t> GetSaturatedPulseLengthData()")
        write_tile_tensor_data(out, "uint32_t", "lInputData", data_array, 1, tile_scan_count, tile_pd_count)
        newline(out)
        return_(out, "lInputData")
        end_function(out)

        begin_function(out, "OpNode GetSaturatedPulseLengthNode(Scope &aScope)")
        out.write("    auto lNodeData = GetSaturatedPulseLengthData();\n")
        write_tensor_shape(out, "uint32_t", "lTensorShape", [1, tile_scan_count, tile_pd_count, int(len(data_array) / (tile_scan_count * tile_pd_count))])
        create_tensor_node(out, "lNodeData", "lNode", "lTensorShape")
        return_(out, "lNode")
        end_function(out)

    with open(TEST_INCLUDE_ROOT / "TestLastUnsaturatedSample.cpp", 'w') as out:
        write_header(out)
        newline(out)
        out.write('#include "TestDataFunctions.h"\n\n\n')

        data_array = result_blinder['smpl_before'].to_numpy()
        begin_function(out, "std::vector<float> GetLastUnsaturatedSampleData()")
        write_tile_tensor_data(out, "float", "lInputData", data_array, 1, tile_scan_count, tile_pd_count)
        newline(out)
        return_(out, "lInputData")
        end_function(out)

        begin_function(out, "OpNode GetLastUnsaturatedSampleNode(Scope &aScope)")
        out.write("    auto lNodeData = GetLastUnsaturatedSampleData();\n")
        write_tensor_shape(out, "float", "lTensorShape", [1, tile_scan_count, tile_pd_count, int(len(data_array) / (tile_scan_count * tile_pd_count))])
        create_tensor_node(out, "lNodeData", "lNode", "lTensorShape")
        return_(out, "lNode")
        end_function(out)

    with open(TEST_INCLUDE_ROOT / "TestBlinderOutput.cpp", 'w') as out:
        write_header(out)
        newline(out)
        out.write('#include "TestDataFunctions.h"\n\n\n')

        data_array = result_blinder['data_o'].to_numpy()
        begin_function(out, "std::vector<float> GetBlinderOutputData()")
        write_tile_tensor_data(out, "float", "lInputData", data_array, 1, tile_scan_count, tile_pd_count)
        newline(out)
        return_(out, "lInputData")
        end_function(out)

        begin_function(out, "OpNode GetBlinderOutputNode(Scope &aScope)")
        out.write("    auto lNodeData = GetBlinderOutputData();\n")
        write_tensor_shape(out, "float", "lTensorShape", [1, tile_scan_count, tile_pd_count, int(len(data_array) / (tile_scan_count * tile_pd_count))])
        create_tensor_node(out, "lNodeData", "lNode", "lTensorShape")
        return_(out, "lNode")
        end_function(out)

    with open(TEST_INCLUDE_ROOT / "TestValidDetections.cpp", 'w') as out:
        write_header(out)
        newline(out)
        out.write('#include "TestDataFunctions.h"\n\n\n')

        begin_function(out, "std::vector<uint8_t> GetValidDetectionData()")
        grouped = result_detect_max.groupby(['trace'])
        data = []
        for name, group in grouped:
            data.append((name, list(group["det_index"].to_numpy())))

        valid_detections = np.zeros([tile_waveform_count, traces.shape[1]], dtype=np.uint8)
        for indices in data:
            valid_detections[indices[0], indices[1]] = 1

        write_tensor(out, "uint8_t", "lInputData", valid_detections, 1, tile_scan_count, tile_pd_count)
        newline(out)
        return_(out, "lInputData")
        end_function(out)

        begin_function(out, "OpNode GetValidDetectionNode(Scope &aScope)")
        out.write("    auto lNodeData = GetValidDetectionData();\n")
        write_tensor_shape(out, "uint8_t", "lTensorShape", [1, tile_scan_count, tile_pd_count, int(len(data_array) / (tile_scan_count * tile_pd_count))])
        create_tensor_node(out, "lNodeData", "lNode", "lTensorShape")
        return_(out, "lNode")
        end_function(out)


    with open(TEST_INCLUDE_ROOT / "TestValidDetectionCount.cpp", 'w') as out:
        write_header(out)
        newline(out)
        out.write('#include "TestDataFunctions.h"\n\n\n')

        begin_function(out, "std::vector<uint32_t> GetValidDetectionCountData()")
        grouped = result_detect_max.groupby(['trace'])
        data = []
        for name, group in grouped:
            data.append((name, len(list(group["det_index"].to_numpy()))))
        valid_detections = np.zeros([tile_waveform_count, 1], dtype=np.uint32)
        for indices in data:
            valid_detections[indices[0], 0] = indices[1]
        data = np.reshape(valid_detections, (-1, tile_pd_count, tile_scan_count))
        data = data[:, 0:tile_pd_count, 0:tile_scan_count]
        data = np.transpose(data, [0, 2, 1])
        out_array = np.reshape(data, (1, tile_scan_count, tile_pd_count))
        write_waveform_array(out, "uint32_t", "lDataNode", out_array, True)
        newline(out)
        return_(out, "lDataNode")
        end_function(out)

        begin_function(out, "OpNode GetValidDetectionCountNode(Scope &aScope)")
        out.write("    auto lNodeData = GetValidDetectionCountData();\n")
        write_tensor_shape(out, "uint32_t", "lTensorShape", [1, tile_scan_count, tile_pd_count ])
        create_tensor_node(out, "lNodeData", "lNode", "lTensorShape")
        return_(out, "lNode")
        end_function(out)

    with open(TEST_INCLUDE_ROOT / "TestDetectionMetadata.cpp", 'w') as out:
        write_header(out)
        newline(out)
        out.write('#include "TestDataFunctions.h"\n\n\n')

        begin_function(out, "std::vector<uint32_t> GetDetectionMetadata()")
        out_array = np.reshape(result_tile, [1, tile_pd_count, tile_scan_count, -1])
        out_array = out_array[:, :, :, 5:9]
        out_array = np.transpose(out_array, [0, 2, 1, 3])
        out_array = np.reshape(out_array, [1, tile_pd_count * tile_scan_count, -1])
        write_waveform_array(out, "uint32_t", "lOutputData", out_array, True)
        newline(out)
        out.write("    return lOutputData;\n")
        end_function(out)

    with open(TEST_INCLUDE_ROOT / "TestPacketTraceData.cpp", 'w') as out:
        write_header(out)
        newline(out)
        out.write('#include "TestDataFunctions.h"\n\n\n')

        begin_function(out, "std::vector<uint32_t> GetPacketTraceData()")
        out_array = np.reshape(result_tile, [1, tile_pd_count, tile_scan_count, -1])
        out_array = out_array[:, :, :, 9:20]
        out_array = np.transpose(out_array, [0, 2, 1, 3])
        out_array = np.reshape(out_array, [1, tile_pd_count * tile_scan_count, -1])
        write_waveform_array(out, "uint32_t", "lOutputData", out_array, True)
        newline(out)
        out.write("    return lOutputData;\n")
        end_function(out)

    with open(TEST_INCLUDE_ROOT / "TestDataFunctions.h", 'w') as out:
        write_header(out)
        newline(out)

        out.write('#include <vector>\n')
        out.write('#include "TensorOps/Scope.h"\n')
        out.write('\n\n\n')
        out.write('using namespace LTSE::TensorOps;\n')
        write_signatures(out)

def write_input(df):
    sample_col_names = [x for x in df.columns if x.startswith("Sample")]
    df0 = df[sample_col_names]
    input_file_name = f"{working_fpga_tmp_root}/input_0.csv"
    df0.to_csv(input_file_name, sep=",")
    return input_file_name

def run_fpga_reference_model(input_df):

    cwd = os.getcwd()
    os.chdir(str(working_fpga_tmp_root))

    df = input_df[0:tile_waveform_count]
    try:
        in_file = write_input(df)
        octave.warning("off")
        octave.eval(f"cd {str(working_fpga_tmp_root)}")
        octave.addpath(reference_model_executable_path.replace("\\", "/"))
        octave.fpga_model(
            str(in_file), reference_model_config_path.replace("\\", "/"))
        df0 = create_fpga_output_dataframe(df, working_fpga_tmp_root)
        os.chdir(cwd)
        return df0
    except Exception as e:
        print(e)
        os.chdir(cwd)
        return None


df = ltl_to_df("D:\\FLM_Data\\Dspace-plan_test-19-07-2022\\Dspace-plan_test-19-07-2022\\Dspace-FLM0\\Single tile fidelity\\Dspace-raw_traces_recording-ARRET_15m.ltl")
df = run_fpga_reference_model(df)
